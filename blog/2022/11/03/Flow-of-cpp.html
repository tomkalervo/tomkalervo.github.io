<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Getting the flow of c++ | Tom Karlsson</title>
<meta name="generator" content="Jekyll v4.2.2" />
<meta property="og:title" content="Getting the flow of c++" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="If you have a bipartite graph and want to get a maximum matching - you can reduce the problem by building a flow graph and calculate its maximum flow. Ford and Fulkerson are the inventors behind the method Ford-Fulkerson which calculates the maximal flow through a directed graph. When implemented using breadth-first search you get the Edmonds-Karp algorithm. You have to keep an adjacency list of vertices as well as edge-information for forward edges and backward edges. Using c++ I was able to effectively search, save paths and update the flow. First off we need a good way to store the data for each edge. This is done with a struct called edgeflow and a global vector edge_list that is an adjacency list (of edges). struct edgeflow { int from, to, flow, capacity; struct edgeflow *reverse; }; vector&lt;list&lt;edgeflow *&gt;&gt; edge_list; For each edge we create an edgeflow pointer, allocate memory, set all the variables and insert the pointer into edge_list. For each edge we also create a backwards-edge which is linked together with the forward-edge using the reverse pointer. This edge is also added to edge_list. // for all edges (v,u), c is edge capacity of (v,u) struct edgeflow *a = (struct edgeflow *)malloc(sizeof(struct edgeflow)); struct edgeflow *b = (struct edgeflow *)malloc(sizeof(struct edgeflow)); a-&gt;from = v; b-&gt;from = u; a-&gt;to = u; b-&gt;to = v; a-&gt;flow = 0; b-&gt;flow = 0; a-&gt;capacity = c; b-&gt;capacity = 0; a-&gt;reverse = b; b-&gt;reverse = a; edge_list.at(v).push_back(a); edge_list.at(u).push_back(b); Now we can start calculating the max flow from the node start to the node sink. While a possible path is found from start to sink we continue to increase flow along this path: void calculateMaxFlow() { int flow = 0; list&lt;edgeflow *&gt; path; flow = BFS(path); while (!(flow == 0)) { for (; !path.empty(); path.pop_front()) { edgeflow *e = path.front(); e-&gt;flow = e-&gt;flow + flow; e-&gt;reverse-&gt;flow = e-&gt;flow * -1; } maxflow += flow; flow = BFS(path); } } Here we can really utilize the pointers. The path built by BFS is a list with pointers to each edge. We get instant access to these objects and can update their values. Let us see how the path is found using BFS: int BFS(list&lt;edgeflow *&gt; &amp;path) { vector&lt;edgeflow *&gt; parent; parent.resize(vertex_total + 1, NULL); queue&lt;int&gt; q; q.push(start); while (!q.empty() &amp;&amp; parent[sink] == NULL) { int v = q.front(); q.pop(); for (edgeflow *e : edge_list[v]) { // is there capacity left in e? If so we can use it in our path int possible_flow = e-&gt;capacity - e-&gt;flow; // if not visited and there exists a flow, we add edge e to the BFS-queue and mark it as visited if ((parent[e-&gt;to] == NULL) &amp;&amp; (possible_flow &gt; 0)) { parent[e-&gt;to] = e; q.push(e-&gt;to); } } } if (parent[sink] == NULL) return 0; else { edgeflow *e = parent[sink]; int min_flow = e-&gt;capacity - e-&gt;flow; path.push_front(e); while (e-&gt;from != start) { e = parent[e-&gt;from]; min_flow = (e-&gt;capacity - e-&gt;flow) &lt; min_flow ? (e-&gt;capacity - e-&gt;flow) : min_flow; path.push_front(e); } return min_flow; } } Since path is a list type it is implicitly declared as a pointer. This means that we receive its address as the argument in BFS. All operations done to the path inside BFS can be accessed outside BFS aswell. Looking at time efficency we see that the method of finding the maximum flow is only bound by the speed of breadth first search times the number of possible paths in the graph." />
<meta property="og:description" content="If you have a bipartite graph and want to get a maximum matching - you can reduce the problem by building a flow graph and calculate its maximum flow. Ford and Fulkerson are the inventors behind the method Ford-Fulkerson which calculates the maximal flow through a directed graph. When implemented using breadth-first search you get the Edmonds-Karp algorithm. You have to keep an adjacency list of vertices as well as edge-information for forward edges and backward edges. Using c++ I was able to effectively search, save paths and update the flow. First off we need a good way to store the data for each edge. This is done with a struct called edgeflow and a global vector edge_list that is an adjacency list (of edges). struct edgeflow { int from, to, flow, capacity; struct edgeflow *reverse; }; vector&lt;list&lt;edgeflow *&gt;&gt; edge_list; For each edge we create an edgeflow pointer, allocate memory, set all the variables and insert the pointer into edge_list. For each edge we also create a backwards-edge which is linked together with the forward-edge using the reverse pointer. This edge is also added to edge_list. // for all edges (v,u), c is edge capacity of (v,u) struct edgeflow *a = (struct edgeflow *)malloc(sizeof(struct edgeflow)); struct edgeflow *b = (struct edgeflow *)malloc(sizeof(struct edgeflow)); a-&gt;from = v; b-&gt;from = u; a-&gt;to = u; b-&gt;to = v; a-&gt;flow = 0; b-&gt;flow = 0; a-&gt;capacity = c; b-&gt;capacity = 0; a-&gt;reverse = b; b-&gt;reverse = a; edge_list.at(v).push_back(a); edge_list.at(u).push_back(b); Now we can start calculating the max flow from the node start to the node sink. While a possible path is found from start to sink we continue to increase flow along this path: void calculateMaxFlow() { int flow = 0; list&lt;edgeflow *&gt; path; flow = BFS(path); while (!(flow == 0)) { for (; !path.empty(); path.pop_front()) { edgeflow *e = path.front(); e-&gt;flow = e-&gt;flow + flow; e-&gt;reverse-&gt;flow = e-&gt;flow * -1; } maxflow += flow; flow = BFS(path); } } Here we can really utilize the pointers. The path built by BFS is a list with pointers to each edge. We get instant access to these objects and can update their values. Let us see how the path is found using BFS: int BFS(list&lt;edgeflow *&gt; &amp;path) { vector&lt;edgeflow *&gt; parent; parent.resize(vertex_total + 1, NULL); queue&lt;int&gt; q; q.push(start); while (!q.empty() &amp;&amp; parent[sink] == NULL) { int v = q.front(); q.pop(); for (edgeflow *e : edge_list[v]) { // is there capacity left in e? If so we can use it in our path int possible_flow = e-&gt;capacity - e-&gt;flow; // if not visited and there exists a flow, we add edge e to the BFS-queue and mark it as visited if ((parent[e-&gt;to] == NULL) &amp;&amp; (possible_flow &gt; 0)) { parent[e-&gt;to] = e; q.push(e-&gt;to); } } } if (parent[sink] == NULL) return 0; else { edgeflow *e = parent[sink]; int min_flow = e-&gt;capacity - e-&gt;flow; path.push_front(e); while (e-&gt;from != start) { e = parent[e-&gt;from]; min_flow = (e-&gt;capacity - e-&gt;flow) &lt; min_flow ? (e-&gt;capacity - e-&gt;flow) : min_flow; path.push_front(e); } return min_flow; } } Since path is a list type it is implicitly declared as a pointer. This means that we receive its address as the argument in BFS. All operations done to the path inside BFS can be accessed outside BFS aswell. Looking at time efficency we see that the method of finding the maximum flow is only bound by the speed of breadth first search times the number of possible paths in the graph." />
<link rel="canonical" href="/blog/2022/11/03/Flow-of-cpp.html" />
<meta property="og:url" content="/blog/2022/11/03/Flow-of-cpp.html" />
<meta property="og:site_name" content="Tom Karlsson" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-11-03T17:15:46+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Getting the flow of c++" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-11-03T17:15:46+00:00","datePublished":"2022-11-03T17:15:46+00:00","description":"If you have a bipartite graph and want to get a maximum matching - you can reduce the problem by building a flow graph and calculate its maximum flow. Ford and Fulkerson are the inventors behind the method Ford-Fulkerson which calculates the maximal flow through a directed graph. When implemented using breadth-first search you get the Edmonds-Karp algorithm. You have to keep an adjacency list of vertices as well as edge-information for forward edges and backward edges. Using c++ I was able to effectively search, save paths and update the flow. First off we need a good way to store the data for each edge. This is done with a struct called edgeflow and a global vector edge_list that is an adjacency list (of edges). struct edgeflow { int from, to, flow, capacity; struct edgeflow *reverse; }; vector&lt;list&lt;edgeflow *&gt;&gt; edge_list; For each edge we create an edgeflow pointer, allocate memory, set all the variables and insert the pointer into edge_list. For each edge we also create a backwards-edge which is linked together with the forward-edge using the reverse pointer. This edge is also added to edge_list. // for all edges (v,u), c is edge capacity of (v,u) struct edgeflow *a = (struct edgeflow *)malloc(sizeof(struct edgeflow)); struct edgeflow *b = (struct edgeflow *)malloc(sizeof(struct edgeflow)); a-&gt;from = v; b-&gt;from = u; a-&gt;to = u; b-&gt;to = v; a-&gt;flow = 0; b-&gt;flow = 0; a-&gt;capacity = c; b-&gt;capacity = 0; a-&gt;reverse = b; b-&gt;reverse = a; edge_list.at(v).push_back(a); edge_list.at(u).push_back(b); Now we can start calculating the max flow from the node start to the node sink. While a possible path is found from start to sink we continue to increase flow along this path: void calculateMaxFlow() { int flow = 0; list&lt;edgeflow *&gt; path; flow = BFS(path); while (!(flow == 0)) { for (; !path.empty(); path.pop_front()) { edgeflow *e = path.front(); e-&gt;flow = e-&gt;flow + flow; e-&gt;reverse-&gt;flow = e-&gt;flow * -1; } maxflow += flow; flow = BFS(path); } } Here we can really utilize the pointers. The path built by BFS is a list with pointers to each edge. We get instant access to these objects and can update their values. Let us see how the path is found using BFS: int BFS(list&lt;edgeflow *&gt; &amp;path) { vector&lt;edgeflow *&gt; parent; parent.resize(vertex_total + 1, NULL); queue&lt;int&gt; q; q.push(start); while (!q.empty() &amp;&amp; parent[sink] == NULL) { int v = q.front(); q.pop(); for (edgeflow *e : edge_list[v]) { // is there capacity left in e? If so we can use it in our path int possible_flow = e-&gt;capacity - e-&gt;flow; // if not visited and there exists a flow, we add edge e to the BFS-queue and mark it as visited if ((parent[e-&gt;to] == NULL) &amp;&amp; (possible_flow &gt; 0)) { parent[e-&gt;to] = e; q.push(e-&gt;to); } } } if (parent[sink] == NULL) return 0; else { edgeflow *e = parent[sink]; int min_flow = e-&gt;capacity - e-&gt;flow; path.push_front(e); while (e-&gt;from != start) { e = parent[e-&gt;from]; min_flow = (e-&gt;capacity - e-&gt;flow) &lt; min_flow ? (e-&gt;capacity - e-&gt;flow) : min_flow; path.push_front(e); } return min_flow; } } Since path is a list type it is implicitly declared as a pointer. This means that we receive its address as the argument in BFS. All operations done to the path inside BFS can be accessed outside BFS aswell. Looking at time efficency we see that the method of finding the maximum flow is only bound by the speed of breadth first search times the number of possible paths in the graph.","headline":"Getting the flow of c++","mainEntityOfPage":{"@type":"WebPage","@id":"/blog/2022/11/03/Flow-of-cpp.html"},"url":"/blog/2022/11/03/Flow-of-cpp.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="Tom Karlsson" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Tom Karlsson</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a><a class="page-link" href="/cv/">CV</a><a class="page-link" href="/my_ml/">My Machine Learning Notes</a><a class="page-link" href="/my_unix/">My Unix Commands</a><a class="page-link" href="/studies/">Studies</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Getting the flow of c++</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2022-11-03T17:15:46+00:00" itemprop="datePublished">Nov 3, 2022
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>If you have a bipartite graph and want to get a maximum matching - you can reduce the problem by building a flow graph and calculate its maximum flow.
Ford and Fulkerson are the inventors behind the method <a href="https://en.wikipedia.org/wiki/Ford?Fulkerson_algorithm">Ford-Fulkerson</a> which calculates the maximal flow through a directed graph. When implemented using breadth-first search you get the <a href="https://en.wikipedia.org/wiki/Edmonds?Karp_algorithm">Edmonds-Karp</a> algorithm. You have to keep an adjacency list of vertices as well as edge-information for forward edges and backward edges. Using c++ I was able to effectively search, save paths and update the flow. First off we need a good way to store the data for each edge. This is done with a struct called <em>edgeflow</em> and a global vector <em>edge_list</em> that is an adjacency list (of edges).</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">struct</span> <span class="nc">edgeflow</span>
<span class="p">{</span>
   <span class="kt">int</span> <span class="n">from</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">flow</span><span class="p">,</span> <span class="n">capacity</span><span class="p">;</span>
   <span class="k">struct</span> <span class="nc">edgeflow</span> <span class="o">*</span><span class="n">reverse</span><span class="p">;</span>
<span class="p">};</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">list</span><span class="o">&lt;</span><span class="n">edgeflow</span> <span class="o">*&gt;&gt;</span> <span class="n">edge_list</span><span class="p">;</span></code></pre></figure>

<p>For each edge we create an edgeflow pointer, allocate memory, set all the variables and insert the pointer into <em>edge_list</em>. For each edge we also create a backwards-edge which is linked together with the forward-edge using the reverse pointer. This edge is also added to <em>edge_list</em>.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="c1">// for all edges (v,u), c is edge capacity of (v,u)</span>
<span class="k">struct</span> <span class="nc">edgeflow</span> <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="nc">edgeflow</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="nc">edgeflow</span><span class="p">));</span>
<span class="k">struct</span> <span class="nc">edgeflow</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="nc">edgeflow</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="nc">edgeflow</span><span class="p">));</span>
<span class="n">a</span><span class="o">-&gt;</span><span class="n">from</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
<span class="n">b</span><span class="o">-&gt;</span><span class="n">from</span> <span class="o">=</span> <span class="n">u</span><span class="p">;</span>
<span class="n">a</span><span class="o">-&gt;</span><span class="n">to</span> <span class="o">=</span> <span class="n">u</span><span class="p">;</span>
<span class="n">b</span><span class="o">-&gt;</span><span class="n">to</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
<span class="n">a</span><span class="o">-&gt;</span><span class="n">flow</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">b</span><span class="o">-&gt;</span><span class="n">flow</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">a</span><span class="o">-&gt;</span><span class="n">capacity</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
<span class="n">b</span><span class="o">-&gt;</span><span class="n">capacity</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">a</span><span class="o">-&gt;</span><span class="n">reverse</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
<span class="n">b</span><span class="o">-&gt;</span><span class="n">reverse</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
<span class="n">edge_list</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">v</span><span class="p">).</span><span class="n">push_back</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
<span class="n">edge_list</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">u</span><span class="p">).</span><span class="n">push_back</span><span class="p">(</span><span class="n">b</span><span class="p">);</span></code></pre></figure>

<p>Now we can start calculating the max flow from the node <em>start</em> to the node <em>sink</em>. While a possible path is found from <em>start</em> to <em>sink</em> we continue to increase flow along this path:</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span> <span class="nf">calculateMaxFlow</span><span class="p">()</span>
<span class="p">{</span>
   <span class="kt">int</span> <span class="n">flow</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
   <span class="n">list</span><span class="o">&lt;</span><span class="n">edgeflow</span> <span class="o">*&gt;</span> <span class="n">path</span><span class="p">;</span>
   <span class="n">flow</span> <span class="o">=</span> <span class="n">BFS</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
   <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flow</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
   <span class="p">{</span>
       <span class="k">for</span> <span class="p">(;</span> <span class="o">!</span><span class="n">path</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span> <span class="n">path</span><span class="p">.</span><span class="n">pop_front</span><span class="p">())</span>
       <span class="p">{</span>
           <span class="n">edgeflow</span> <span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="n">path</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
           <span class="n">e</span><span class="o">-&gt;</span><span class="n">flow</span> <span class="o">=</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">flow</span> <span class="o">+</span> <span class="n">flow</span><span class="p">;</span>
           <span class="n">e</span><span class="o">-&gt;</span><span class="n">reverse</span><span class="o">-&gt;</span><span class="n">flow</span> <span class="o">=</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">flow</span> <span class="o">*</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
       <span class="p">}</span>
       <span class="n">maxflow</span> <span class="o">+=</span> <span class="n">flow</span><span class="p">;</span>
       <span class="n">flow</span> <span class="o">=</span> <span class="n">BFS</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
   <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>Here we can really utilize the pointers. The path built by <em>BFS</em> is a list with pointers to each edge. We get instant access to these objects and can update their values. Let us see how the path is found using <em>BFS</em>:</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">int</span> <span class="nf">BFS</span><span class="p">(</span><span class="n">list</span><span class="o">&lt;</span><span class="n">edgeflow</span> <span class="o">*&gt;</span> <span class="o">&amp;</span><span class="n">path</span><span class="p">)</span>
<span class="p">{</span>
   <span class="n">vector</span><span class="o">&lt;</span><span class="n">edgeflow</span> <span class="o">*&gt;</span> <span class="n">parent</span><span class="p">;</span>
   <span class="n">parent</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">vertex_total</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
 
   <span class="n">queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">q</span><span class="p">;</span>
   <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>
   <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">parent</span><span class="p">[</span><span class="n">sink</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
   <span class="p">{</span>
       <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
       <span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
 
       <span class="k">for</span> <span class="p">(</span><span class="n">edgeflow</span> <span class="o">*</span><span class="n">e</span> <span class="o">:</span> <span class="n">edge_list</span><span class="p">[</span><span class="n">v</span><span class="p">])</span>
       <span class="p">{</span>
 
           <span class="c1">// is there capacity left  in e? If so we can use it in our path</span>
           <span class="kt">int</span> <span class="n">possible_flow</span> <span class="o">=</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">capacity</span> <span class="o">-</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">flow</span><span class="p">;</span>
 
           <span class="c1">// if not visited and there exists a flow, we add edge e to the BFS-queue and mark it as visited</span>
           <span class="k">if</span> <span class="p">((</span><span class="n">parent</span><span class="p">[</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">to</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">possible_flow</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span>
           <span class="p">{</span>
               <span class="n">parent</span><span class="p">[</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">to</span><span class="p">]</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span>
               <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">to</span><span class="p">);</span>
           <span class="p">}</span>
       <span class="p">}</span>
   <span class="p">}</span>
 
   <span class="k">if</span> <span class="p">(</span><span class="n">parent</span><span class="p">[</span><span class="n">sink</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
       <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
   <span class="k">else</span>
   <span class="p">{</span>
       <span class="n">edgeflow</span> <span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="n">parent</span><span class="p">[</span><span class="n">sink</span><span class="p">];</span>
       <span class="kt">int</span> <span class="n">min_flow</span> <span class="o">=</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">capacity</span> <span class="o">-</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">flow</span><span class="p">;</span>
       <span class="n">path</span><span class="p">.</span><span class="n">push_front</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
 
       <span class="k">while</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">from</span> <span class="o">!=</span> <span class="n">start</span><span class="p">)</span>
       <span class="p">{</span>
           <span class="n">e</span> <span class="o">=</span> <span class="n">parent</span><span class="p">[</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">from</span><span class="p">];</span>
           <span class="n">min_flow</span> <span class="o">=</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">capacity</span> <span class="o">-</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">flow</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">min_flow</span> <span class="o">?</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">capacity</span> <span class="o">-</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">flow</span><span class="p">)</span> <span class="o">:</span> <span class="n">min_flow</span><span class="p">;</span>
           <span class="n">path</span><span class="p">.</span><span class="n">push_front</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
       <span class="p">}</span>
 
       <span class="k">return</span> <span class="n">min_flow</span><span class="p">;</span>
   <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>Since path is a list type it is implicitly declared as a pointer. This means that we receive its address as the argument in <em>BFS</em>. All operations done to the path inside <em>BFS</em> can be accessed outside <em>BFS</em> aswell. Looking at time efficency we see that the method of finding the maximum flow is only bound by the speed of breadth first search times the number of possible paths in the graph.</p>


  </div><a class="u-url" href="/blog/2022/11/03/Flow-of-cpp.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Tom Karlsson</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Tom Karlsson</li><li><a class="u-email" href="mailto:tom.kg.karlsson@gmail.com">tom.kg.karlsson@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/tomkalervo"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">tomkalervo</span></a></li><li><a href="https://www.twitter.com/tomkalervo"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">tomkalervo</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Programmer and Data Scientist with BSc in Information Technology.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
